{"ast":null,"code":"import { Heap } from \"./heap\";\n\n// function runDijkstra (active, visited, setVisited, setCurrent, nodeMap, startNode, endNode, resolve) {\n//     if (active.isEmpty()) {\n//         resolve();\n//         return; \n//     }\n// }\n\nexport const dijkstra = async (links, startNode, endNode, updateVisual) => {\n  console.log(\"inside dijkstras...\");\n  const nodeMap = new Map();\n  for (const link of links) {\n    if (nodeMap.has(link.source)) {\n      nodeMap.get(link.source).push(link);\n    } else {\n      nodeMap.set(link.source, [link]);\n    }\n  }\n\n  // console.log(\"nodemap\")\n  // console.log(nodeMap); \n\n  const visited = new Set(); // set of visited endNodes \n\n  const active = new Heap(comparePaths);\n  const startPath = {\n    start: startNode,\n    end: startNode,\n    steps: [],\n    weight: 0\n  };\n  active.add(startPath);\n  while (!active.isEmpty()) {\n    const minPath = active.remove();\n    console.log(\"dijkstra visited\");\n    console.log(visited);\n    console.log(\"dijkstra current\");\n    console.log(minPath.end);\n    await new Promise(resolve => {\n      setTimeout(() => {\n        // setVisited([...visited]); // set visited nodes to current set\n        // setCurrent(minPath.end); // set currentNode beign processed to current end of path\n        updateVisual([...visited], minPath.end);\n        resolve();\n      }, 1000);\n    });\n\n    // console.log(\"while loop...\")\n    // console.log(minPath) \n    if (minPath.start === startNode && minPath.end === endNode) {\n      visited.add(minPath.end);\n      // console.log(\"dijkstra visited\")\n      // console.log(visited)\n      // console.log(\"dijkstra current\")\n      // console.log(minPath.end)\n      // updateVisual([...visited], minPath.end)\n      return minPath;\n    }\n    if (visited.has(minPath.end)) {\n      continue;\n    }\n    visited.add(minPath.end);\n    if (!nodeMap.has(minPath.end)) {\n      continue;\n    }\n    for (const link of nodeMap.get(minPath.end)) {\n      if (!visited.has(link.target)) {\n        const newPath = {\n          start: startNode,\n          end: link.target,\n          steps: minPath.steps.concat([link]),\n          weight: minPath.weight + parseInt(link.weight)\n        };\n        active.add(newPath);\n      }\n    }\n  }\n  return undefined;\n};\nconst comparePaths = (pathA, pathB) => {\n  return pathA.weight - pathB.weight;\n};","map":{"version":3,"names":["Heap","dijkstra","links","startNode","endNode","updateVisual","console","log","nodeMap","Map","link","has","source","get","push","set","visited","Set","active","comparePaths","startPath","start","end","steps","weight","add","isEmpty","minPath","remove","Promise","resolve","setTimeout","target","newPath","concat","parseInt","undefined","pathA","pathB"],"sources":["/Users/viviansun/d3-test/frontend/src/algorithm/dijkstra.js"],"sourcesContent":["import { Heap } from \"./heap\";\n\n// function runDijkstra (active, visited, setVisited, setCurrent, nodeMap, startNode, endNode, resolve) {\n//     if (active.isEmpty()) {\n//         resolve();\n//         return; \n//     }\n// }\n\nexport const dijkstra = async (links, startNode, endNode, updateVisual) => {\n    console.log(\"inside dijkstras...\")\n    const nodeMap = new Map(); \n\n    for (const link of links) {\n        if (nodeMap.has(link.source)) {\n            nodeMap.get(link.source).push(link); \n        } else { \n            nodeMap.set(link.source, [link]); \n        }\n    }\n\n    // console.log(\"nodemap\")\n    // console.log(nodeMap); \n\n    const visited = new Set(); // set of visited endNodes \n    \n    const active = new Heap(comparePaths);\n    const startPath = {start: startNode, end: startNode, steps: [], weight: 0}\n    active.add(startPath); \n\n    while (!active.isEmpty()) {\n        const minPath = active.remove();\n        console.log(\"dijkstra visited\")\n        console.log(visited)\n        console.log(\"dijkstra current\")\n        console.log(minPath.end)\n        \n        await new Promise((resolve) => {\n            setTimeout(() => {\n                // setVisited([...visited]); // set visited nodes to current set\n                // setCurrent(minPath.end); // set currentNode beign processed to current end of path\n                updateVisual([...visited], minPath.end)\n                resolve(); \n            }, 1000)\n        });\n\n        // console.log(\"while loop...\")\n        // console.log(minPath) \n        if (minPath.start === startNode && minPath.end === endNode) {\n            visited.add(minPath.end);\n            // console.log(\"dijkstra visited\")\n            // console.log(visited)\n            // console.log(\"dijkstra current\")\n            // console.log(minPath.end)\n            // updateVisual([...visited], minPath.end)\n            return minPath;  \n        } \n\n        if (visited.has(minPath.end)) {\n            continue; \n        }\n\n        visited.add(minPath.end);\n        \n        if (!nodeMap.has(minPath.end)) {\n            continue; \n        }\n        for (const link of nodeMap.get(minPath.end)) {\n            if (!visited.has(link.target)) {\n                const newPath = {\n                    start: startNode, \n                    end: link.target, \n                    steps: minPath.steps.concat([link]), \n                    weight: minPath.weight + parseInt(link.weight)\n                }\n                active.add(newPath); \n            }\n        }\n\n    }\n    return undefined; \n}\n\nconst comparePaths = (pathA, pathB) => {\n    return pathA.weight - pathB.weight; \n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}