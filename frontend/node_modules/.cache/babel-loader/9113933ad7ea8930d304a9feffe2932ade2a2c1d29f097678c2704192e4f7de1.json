{"ast":null,"code":"import { Heap } from \"./heap\";\nexport const dijkstra = (links, startNode, endNode, setVisited, setCurrent) => {\n  const nodeMap = new Map();\n  for (const link of links) {\n    if (nodeMap.has(link.source)) {\n      nodeMap.get(link.source).push(link);\n    } else {\n      nodeMap.set(link.source, [link]);\n    }\n  }\n  const visited = new Set(); // set of visited endNodes \n\n  const active = new Heap(comparePaths);\n  const startPath = {\n    start: startNode,\n    end: startNode,\n    steps: [],\n    weight: 0\n  };\n  active.add(startPath);\n  while (!active.isEmpty()) {\n    const minPath = active.remove();\n    if (minPath.start === startNode && minPath.end === endNode) {\n      visited.add(minPath.end);\n      setVisited([...visited]); // set visited nodes to current set\n      setCurrent(minPath.end);\n      return minPath;\n    }\n    if (visited.has(minPath.end)) {\n      continue;\n    }\n    visited.add(minPath.end);\n    setTimeout(() => {\n      setVisited([...visited]); // set visited nodes to current set\n      setCurrent(minPath.end); // set currentNode beign processed to current end of path\n    }, 1000);\n    for (const link of nodeMap.get(minPath.end)) {\n      if (!visited.has(link.target)) {\n        const newPath = {\n          start: startNode,\n          end: link.target,\n          steps: minPath.steps.concat([link]),\n          weight: minPath.weight + link.weight\n        };\n        active.add(newPath);\n      }\n    }\n  }\n  return undefined;\n};\nconst comparePaths = (pathA, pathB) => {\n  return pathA.weight - pathB.weight;\n};","map":{"version":3,"names":["Heap","dijkstra","links","startNode","endNode","setVisited","setCurrent","nodeMap","Map","link","has","source","get","push","set","visited","Set","active","comparePaths","startPath","start","end","steps","weight","add","isEmpty","minPath","remove","setTimeout","target","newPath","concat","undefined","pathA","pathB"],"sources":["/Users/viviansun/d3-test/src/algorithm/dijkstra.js"],"sourcesContent":["import { Heap } from \"./heap\";\n\nexport const dijkstra = (links, startNode, endNode, setVisited, setCurrent) => {\n    const nodeMap = new Map(); \n\n    for (const link of links) {\n        if (nodeMap.has(link.source)) {\n            nodeMap.get(link.source).push(link); \n        } else { \n            nodeMap.set(link.source, [link]); \n        }\n    }\n\n    const visited = new Set(); // set of visited endNodes \n    \n    const active = new Heap(comparePaths);\n    const startPath = {start: startNode, end: startNode, steps: [], weight: 0}\n    active.add(startPath); \n\n    while (!active.isEmpty()) {\n        const minPath = active.remove(); \n        if (minPath.start === startNode && minPath.end === endNode) {\n            visited.add(minPath.end);\n            setVisited([...visited]); // set visited nodes to current set\n            setCurrent(minPath.end);\n            return minPath;  \n        } \n\n        if (visited.has(minPath.end)) {\n            continue; \n        }\n\n        visited.add(minPath.end);\n\n        setTimeout(() => {\n            setVisited([...visited]); // set visited nodes to current set\n            setCurrent(minPath.end); // set currentNode beign processed to current end of path\n        }, 1000)\n\n        for (const link of nodeMap.get(minPath.end)) {\n            if (!visited.has(link.target)) {\n                const newPath = {\n                    start: startNode, \n                    end: link.target, \n                    steps: minPath.steps.concat([link]), \n                    weight: minPath.weight + link.weight\n                }\n                active.add(newPath); \n            }\n        }\n\n    }\n    return undefined; \n}\n\nconst comparePaths = (pathA, pathB) => {\n    return pathA.weight - pathB.weight; \n}"],"mappings":"AAAA,SAASA,IAAI,QAAQ,QAAQ;AAE7B,OAAO,MAAMC,QAAQ,GAAGA,CAACC,KAAK,EAAEC,SAAS,EAAEC,OAAO,EAAEC,UAAU,EAAEC,UAAU,KAAK;EAC3E,MAAMC,OAAO,GAAG,IAAIC,GAAG,CAAC,CAAC;EAEzB,KAAK,MAAMC,IAAI,IAAIP,KAAK,EAAE;IACtB,IAAIK,OAAO,CAACG,GAAG,CAACD,IAAI,CAACE,MAAM,CAAC,EAAE;MAC1BJ,OAAO,CAACK,GAAG,CAACH,IAAI,CAACE,MAAM,CAAC,CAACE,IAAI,CAACJ,IAAI,CAAC;IACvC,CAAC,MAAM;MACHF,OAAO,CAACO,GAAG,CAACL,IAAI,CAACE,MAAM,EAAE,CAACF,IAAI,CAAC,CAAC;IACpC;EACJ;EAEA,MAAMM,OAAO,GAAG,IAAIC,GAAG,CAAC,CAAC,CAAC,CAAC;;EAE3B,MAAMC,MAAM,GAAG,IAAIjB,IAAI,CAACkB,YAAY,CAAC;EACrC,MAAMC,SAAS,GAAG;IAACC,KAAK,EAAEjB,SAAS;IAAEkB,GAAG,EAAElB,SAAS;IAAEmB,KAAK,EAAE,EAAE;IAAEC,MAAM,EAAE;EAAC,CAAC;EAC1EN,MAAM,CAACO,GAAG,CAACL,SAAS,CAAC;EAErB,OAAO,CAACF,MAAM,CAACQ,OAAO,CAAC,CAAC,EAAE;IACtB,MAAMC,OAAO,GAAGT,MAAM,CAACU,MAAM,CAAC,CAAC;IAC/B,IAAID,OAAO,CAACN,KAAK,KAAKjB,SAAS,IAAIuB,OAAO,CAACL,GAAG,KAAKjB,OAAO,EAAE;MACxDW,OAAO,CAACS,GAAG,CAACE,OAAO,CAACL,GAAG,CAAC;MACxBhB,UAAU,CAAC,CAAC,GAAGU,OAAO,CAAC,CAAC,CAAC,CAAC;MAC1BT,UAAU,CAACoB,OAAO,CAACL,GAAG,CAAC;MACvB,OAAOK,OAAO;IAClB;IAEA,IAAIX,OAAO,CAACL,GAAG,CAACgB,OAAO,CAACL,GAAG,CAAC,EAAE;MAC1B;IACJ;IAEAN,OAAO,CAACS,GAAG,CAACE,OAAO,CAACL,GAAG,CAAC;IAExBO,UAAU,CAAC,MAAM;MACbvB,UAAU,CAAC,CAAC,GAAGU,OAAO,CAAC,CAAC,CAAC,CAAC;MAC1BT,UAAU,CAACoB,OAAO,CAACL,GAAG,CAAC,CAAC,CAAC;IAC7B,CAAC,EAAE,IAAI,CAAC;IAER,KAAK,MAAMZ,IAAI,IAAIF,OAAO,CAACK,GAAG,CAACc,OAAO,CAACL,GAAG,CAAC,EAAE;MACzC,IAAI,CAACN,OAAO,CAACL,GAAG,CAACD,IAAI,CAACoB,MAAM,CAAC,EAAE;QAC3B,MAAMC,OAAO,GAAG;UACZV,KAAK,EAAEjB,SAAS;UAChBkB,GAAG,EAAEZ,IAAI,CAACoB,MAAM;UAChBP,KAAK,EAAEI,OAAO,CAACJ,KAAK,CAACS,MAAM,CAAC,CAACtB,IAAI,CAAC,CAAC;UACnCc,MAAM,EAAEG,OAAO,CAACH,MAAM,GAAGd,IAAI,CAACc;QAClC,CAAC;QACDN,MAAM,CAACO,GAAG,CAACM,OAAO,CAAC;MACvB;IACJ;EAEJ;EACA,OAAOE,SAAS;AACpB,CAAC;AAED,MAAMd,YAAY,GAAGA,CAACe,KAAK,EAAEC,KAAK,KAAK;EACnC,OAAOD,KAAK,CAACV,MAAM,GAAGW,KAAK,CAACX,MAAM;AACtC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}